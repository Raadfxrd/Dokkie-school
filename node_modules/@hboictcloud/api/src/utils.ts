/**
 * Utils-extension for the HBO-ICT.Cloud library
 *
 * @module
 */
import { DataURL, QueryStringObject } from "./types";

const alphaNumeric =
    "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
const symbols = " `!\"$%^&*()-_=+[{]};:'@#~|,<.>/?\\";
const alphaNumericWithSymbols = alphaNumeric + symbols;
const domParser = new DOMParser();

/**
 * Convert a file-input to a Data-URL
 *
 * @param fileInput - HTMLInputElement or DOM-selector of the file-input.
 *
 * @returns Returns a promise which can either fail (`string` with reason) or succeed ({@link DataURL | `DataURL`} of the file).
 *
 * @example
 * ```ts
 * import { utils } from "@hboictcloud/api";
 *
 * try {
 *     const data = await utils.getDataUrl("#fileInput");
 *
 *     console.log(data);
 * }
 * catch(reason) {
 *     console.log(reason);
 * }
 * ```
 */
export function getDataUrl(
    fileInput: HTMLInputElement | string,
): Promise<DataURL | string> {
    return new Promise(function (resolve, reject) {
        const element: HTMLInputElement =
            typeof fileInput === "string"
                ? <HTMLInputElement>document.querySelector(fileInput)
                : fileInput;

        let file;
        let fileName: string;

        if (element) {
            file = element.files![0];
            fileName = element.value.split(/(\\|\/)/g).pop()!;
        } else {
            reject("Could not find element!");

            return;
        }

        const reader = new FileReader();

        reader.addEventListener(
            "load",
            function () {
                const dataUrl = <string>reader.result;

                const mimeType = dataUrl.match("^data:(.*?);base64,")![1];

                const extensionIndex = fileName.lastIndexOf(".");

                resolve({
                    fileName: fileName,
                    extension:
                        extensionIndex > -1
                            ? fileName.substring(extensionIndex + 1)
                            : "",
                    mimeType: mimeType,
                    isImage: mimeType.indexOf("image/") >= 0,
                    url: dataUrl,
                });
            },
            false,
        );

        if (file) {
            reader.readAsDataURL(file);
        } else {
            reject(`Could not load ${fileName || "file"}!`);
        }
    });
}

/**
 * Create a URL with a querystring
 *
 * @param url - Absolute or relative URL
 * @param queryString - Object with all keys to add to the querystring
 *
 * @returns Returns the created URL
 *
 * @example
 * ```ts
 * import { utils } from "@hboictcloud/api";
 *
 * const url = utils.createUrl("matches.html", {
 *     search: "paris",
 *     filters: [
 *         "tagA",
 *         "tagB"
 *     ]
 * });
 *
 * console.log(url); //matches.html?search=paris&filters=tagA&filters=tagB
 * ```
 */
export function createUrl(
    url: string,
    queryString?: QueryStringObject,
): string {
    let targetUrl = url;

    if (queryString && Object.keys(queryString).length > 0) {
        targetUrl += `?${createQueryString(queryString)}`;
    }

    return targetUrl;
}

/**
 * Generate a `string` of random characters
 *
 * @param length - Length of the `string` to generate
 * @param includeSymbols - Set to `true` to include non-alphanumeric characters, otherwise `false`.
 *
 * @returns Returns the generated random string
 */
export function randomString(length: number, includeSymbols: boolean): string {
    const characters = includeSymbols ? alphaNumericWithSymbols : alphaNumeric;

    const result = [];

    for (let i = 0; i < length; i++) {
        result.push(
            characters.charAt(Math.floor(Math.random() * characters.length)),
        );
    }

    return result.join("");
}

/**
 * Convert a Date-object to an SQL accepted String-format
 *
 * @param inputDate - Date-object to convert
 *
 * @returns SQL accepted String-format of the Date-object
 */
export function toSqlDateTime(inputDate: Date): string {
    const date = new Date(inputDate);
    const dateWithOffset = new Date(
        date.getTime() - date.getTimezoneOffset() * 60000,
    );

    return dateWithOffset.toISOString().slice(0, 19).replace("T", " ");
}

/**
 * Create a copy of a object
 *
 * @param object - Object to copy
 *
 * @returns Copy of the object
 */
export function copyObject(object: any): any {
    return handleCopyObject(object);
}

/**
 * Create a querystring of all keys in a given object
 *
 * @param object - Object to convert to a querystring
 *
 * @returns Querystring of all keys in the object
 *
 * @example
 * ```ts
 * import { utils } from "@hboictcloud/api";
 *
 * const queryString = utils.createQueryString({
 *     search: "paris",
 *     filters: [
 *         "tagA",
 *         "tagB"
 *     ]
 * });
 *
 * console.log(queryString); //search=paris&filters=tagA&filters=tagB
 * ```
 */
export function createQueryString(object: Object): string {
    if (!object) {
        return "";
    }

    const urlParams = new URLSearchParams();

    for (const [name, value] of Object.entries(object)) {
        if (Array.isArray(value)) {
            for (const entry of value) {
                urlParams.append(name, entry || "");
            }
        } else {
            urlParams.append(name, <string>value || "");
        }
    }

    return urlParams.toString();
}

/**
 * Parse all keys of a given querystring to an object
 *
 * @param queryString - Querystring to parse to an object
 *
 * @returns Object with all the keys found in the querystring
 */
export function parseQueryString(queryString: string): any {
    return handleQueryString(queryString);
}

/**
 * Parse a `string` containing HTML to a list of HTML elements
 *
 * @param html - HTML to parse to a list of HTML elements
 *
 * @returns List of all HTML elements
 */
export function parseHtml(html: string): NodeList {
    const htmlDocument = domParser.parseFromString(html, "text/html");

    return htmlDocument.body.childNodes;
}

/**
 * Download a file from a given URL as text and parse it to a list of HTML elements
 *
 * @param url - URL of the HTML-file to download and parse
 * @param options - Additional fetch-configuration to apply during the download
 *
 * @returns Returns a promise with a list of all HTML elements
 */
export async function fetchAndParseHtml(
    url: string,
    options?: RequestInit,
): Promise<NodeList> {
    const data = await fetchText(url, options);

    return parseHtml(data);
}

/**
 * Download a file from a given URL as text
 *
 * @param url - URL of the file to download as text
 * @param options - Additional fetch-configuration to apply during the download
 *
 * @returns Returns a promise with the downloaded text as a string
 */
export async function fetchText(
    url: string,
    options?: RequestInit,
): Promise<string> {
    const response = await fetch(url, options);

    return response.text();
}

/**
 * Download a file from a given URL as JSON
 *
 * @param url - URL of the file to download as JSON
 * @param options - Additional fetch-configuration to apply during the download
 *
 * @returns Returns a promise with the downloaded JSON as an object
 */
export async function fetchJson(
    url: string,
    options?: RequestInit,
): Promise<any> {
    const response = await fetch(url, options);

    return response.json();
}

/**
 * Download a file from a given URL as a blob
 *
 * @param url URL of the file to download as a blob
 * @param options - Additional fetch-configuration to apply during the download
 *
 * @returns Returns a promise with the downloaded file as a blob-object
 */
export async function fetchBlob(
    url: string,
    options?: RequestInit,
): Promise<Blob> {
    const response = await fetch(url, options);

    return response.blob();
}

//Source: https://stackoverflow.com/a/25921504/890815
function handleCopyObject(object: any): any {
    const result: any = Array.isArray(object) ? [] : {};

    let key;
    let value;

    for (key in object) {
        value = object[key];

        result[key] =
            typeof value === "object" && value !== null
                ? copyObject(value)
                : value;
    }

    return result;
}

//Source: https://github.com/medialize/URI.js/blob/gh-pages/src/URI.js
function handleQueryString(string: string): any {
    if (!string) {
        return {};
    }

    // throw out the funky business - "?"[name"="value"&"]+
    string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");

    if (!string) {
        return {};
    }

    const items: any = {};
    const splits = string.split("&");
    const length = splits.length;

    let v, name, value;

    for (let i = 0; i < length; i++) {
        v = splits[i].split("=");
        name = decodeQuery(v.shift()!);
        // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
        value = v.length ? decodeQuery(v.join("=")) : null;

        if (Object.prototype.hasOwnProperty.call(items, name)) {
            if (typeof items[name] === "string" || items[name] === null) {
                items[name] = [items[name]];
            }

            items[name].push(value);
        } else {
            items[name] = value;
        }
    }

    return items;
}

function decodeQuery(string: string): string {
    string += "";

    try {
        return decodeURIComponent(string);
    } catch (e) {
        return string;
    }
}

{"version":3,"file":"hboictcloud-api.js","sources":["../src/api.ts","../src/localization.ts","../src/utils.ts","../src/session.ts","../src/url.ts"],"sourcesContent":["/**\n * API-extension for the HBO-ICT.Cloud library\n *\n * @module\n */\nimport {\n    ApiFailResponse,\n    ApiFailReason,\n    PromiseReject,\n    PromiseResolve,\n    Options,\n    Email,\n} from \"./types\";\n\nlet options: Options = undefined!;\n\n/**\n * Configure the HBO-ICT.Cloud API\n *\n * @param newOptions - Options-object to configure the HBO-ICT.Cloud API\n *\n * @throws When the Options-object is incomplete, an exception is thrown detailing the missing information.\n *\n * @example\n * ```ts\n * import { api } from \"@hboictcloud/api\";\n *\n * api.configure({\n *     url: \"https://api.hbo-ict.cloud\",\n *     apiKey: \"yourapikey\",\n *     database: \"yourdatabasename\",\n *     environment: \"targetenvironment\"\n * });\n * ```\n */\nexport function configure(newOptions: Options): boolean {\n    const errors = [];\n\n    if (!newOptions.url) {\n        errors.push(\"- url => API-URL from HBO-ICT.Cloud\");\n    }\n\n    if (!newOptions.apiKey) {\n        errors.push(\"- apiKey => API-Key from HBO-ICT.Cloud\");\n    }\n\n    if (!newOptions.database) {\n        errors.push(\"- database => Name of target database for queries\");\n    }\n\n    if (!newOptions.environment) {\n        errors.push(\"- environment => Name of the environment\");\n    }\n\n    if (errors.length > 0) {\n        throw `HBO-ICT.Cloud API configuration is missing one or more properties:\\n${errors.join(\n            \"\\n\",\n        )}`;\n    }\n\n    options = newOptions;\n\n    return true;\n}\n\n/**\n * Send an SQL-query to the configured database\n *\n * @param query - Query written in SQL\n * @param values - Array of values to replace question marks (?) in the query with. Replacing is done from left to right.\n *\n * @returns Returns a promise which can either fail (`string` with reason) or succeed (`T[]` with results)\n *\n * @example\n * ```ts\n * import { api } from \"@hboictcloud/api\";\n *\n * try {\n *     const data = await api.queryDatabase(\n *         \"SELECT * FROM test WHERE name = ? and age <= ?\",\n *         [\"Lennard\", 30]\n *     );\n *\n *     console.log(data);\n * }\n * catch(reason: string) {\n *     console.log(reason);\n * }\n * ```\n */\nexport function queryDatabase<T = any>(\n    query: string,\n    ...values: any\n): Promise<T[] | ApiFailReason> {\n    assertConfiguration();\n\n    return handleFetch<T[]>(options.url + \"/db\", {\n        method: \"POST\",\n        headers: {\n            Authorization: `Bearer ${options.apiKey}`,\n        },\n        body: JSON.stringify({\n            query: query,\n            values: values,\n            database: options.database,\n        }),\n    });\n}\n\n/**\n * Send an email\n *\n * @param email - Email-object describing the email to send\n *\n * @returns Returns a promise which can either fail (`string` with reason) or succeed (`string` with status)\n *\n * @example\n * ```ts\n * import { api } from \"@hboictcloud/api\";\n *\n * try {\n *     const data = await api.sendEmail({\n *         from: {\n *             name: \"Group\",\n *             address: \"group@fys.cloud\"\n *         },\n *         to: [\n *             {\n *                 name: \"Lennard Fonteijn\",\n *                 address: \"l.c.j.fonteijn@hva.nl\"\n *             }\n *         ],\n *         subject: \"Just a test!\",\n *         html: \"<h1>Hello Lennard!</h1><p>This is an email :)</p>\"\n *     });\n *\n *     console.log(data);\n * }\n * catch(reason: string) {\n *     console.log(reason);\n * }\n * ```\n */\nexport function sendEmail(email: Email): Promise<string | ApiFailReason> {\n    assertConfiguration();\n\n    return handleFetch<string>(options.url + \"/mail\", {\n        method: \"POST\",\n        headers: {\n            Authorization: `Bearer ${options.apiKey}`,\n        },\n        body: JSON.stringify(email),\n    });\n}\n\n/**\n * Upload a file to the uploads-folder on the configured HBO-ICT.Cloud environment\n *\n * @param fileName - Name of the file to upload, has to contain an extension.\n * @param dataUrl - Data-URL of the file in base64\n * @param [overwrite] - Set to `true` to overwrite an existing file, otherwise `false`. (Default: `false`)\n *\n * @returns {Promise<string>} Returns a promise which can either fail (`string` with reason) or succeed (`string` with URL to file)\n *\n * @example\n * The example below will get the Data-URL from a file-input and upload it as \"test.png\".\n *\n * ```ts\n * import { api, utils } from \"@hboictcloud/api\";\n *\n * try {\n *     const data = await utils.getDataUrl(document.querySelector(\"#fileUpload\"));\n *     const uploadResponse = await api.uploadFile(\"test.png\", data.url);\n *\n *     console.log(data, uploadResponse);\n * }\n * catch(reason: string) {\n *     console.log(reason);\n * }\n * ```\n */\nexport function uploadFile(\n    fileName: string,\n    dataUrl: string,\n    overwrite: boolean = false,\n): Promise<string | ApiFailReason> {\n    assertConfiguration();\n\n    if (!fileName || !dataUrl) {\n        return Promise.reject(\"fileName or dataUrl cannot be empty!\");\n    }\n\n    return handleFetch<string>(options.url + \"/file\", {\n        method: \"POST\",\n        headers: {\n            Authorization: `Bearer ${options.apiKey}`,\n        },\n        body: JSON.stringify({\n            environment: options.environment,\n            fileName: fileName,\n            action: \"upload\",\n            overwrite: overwrite || false,\n            buffer: dataUrl.match(\"^data:(.*?);base64,(.*?)$\")![2],\n        }),\n    });\n}\n\n/**\n * Delete a file from the uploads-folder on the configured HBO-ICT.Cloud environment\n *\n * @param fileName - Path to the file to delete, can contain forward slashes (/) to access subfolders.\n *\n * @returns Returns a promise which can either fail (`string` with reason) or succeed (`string` with \"OK\").\n *\n * @example\n * Below is a simplified example, you will have to add try/catch and async/await structures yourself.\n * ```ts\n * import { api } from \"@hboictcloud/api\";\n *\n * const data = await api.deleteFile(\"test.png\");\n * console.log(data);\n * ```\n */\nexport function deleteFile(fileName: string): Promise<string | ApiFailReason> {\n    assertConfiguration();\n\n    if (!fileName) {\n        return Promise.reject(\"fileName cannot be empty!\");\n    }\n\n    return handleFetch<string>(options.url + \"/file\", {\n        method: \"POST\",\n        headers: {\n            Authorization: `Bearer ${options.apiKey}`,\n        },\n        body: JSON.stringify({\n            environment: options.environment,\n            fileName: fileName,\n            action: \"deleteFile\",\n        }),\n    });\n}\n\n/**\n * Checks if a file exists inside the uploads-folder on the configured HBO-ICT.Cloud environment.\n *\n * @param fileName - Path to the file to check for existence, can contain forward slashes (/) to access subfolders.\n *\n * @returns Returns a promise which can either fail (`string` with reason) or succeed (`boolean` set to `true` if file exists, otherwise `false`).\n *\n * @example\n * Below is a simplified example.\n *\n * ```ts\n * import { api } from \"@hboictcloud/api\";\n *\n * const data = await api.fileExists(\"test.png\");\n * console.log(data);\n * ```\n */\nexport function fileExists(fileName: string): Promise<boolean | ApiFailReason> {\n    assertConfiguration();\n\n    if (!fileName) {\n        return Promise.reject(\"fileName cannot be empty!\");\n    }\n\n    return handleFetch<boolean>(options.url + \"/file\", {\n        method: \"POST\",\n        headers: {\n            Authorization: `Bearer ${options.apiKey}`,\n        },\n        body: JSON.stringify({\n            environment: options.environment,\n            fileName: fileName,\n            action: \"fileExists\",\n        }),\n    });\n}\n\n/**\n * Delete a directory from the uploads-folder on the configured HBO-ICT.Cloud environment, but only when it is empty.\n *\n * @param path - Path to the directory to delete, can contain forward slashes (/) to access subfolders. Folder has to be empty!\n *\n * @returns Returns a promise which can either fail (`string` with reason) or succeed (`string` with \"OK\").\n *\n * @example\n * Below is a simplified example.\n * ```ts\n * import { api } from \"@hboictcloud/api\";\n *\n * const data = await api.deleteDirectory(\"test\");\n * ```\n */\nexport function deleteDirectory(path: string): Promise<string | ApiFailReason> {\n    assertConfiguration();\n\n    /*if (!path) {\n            return Promise.reject(\"path cannot be empty!\");\n        }*/\n\n    return handleFetch<string>(options.url + \"/file\", {\n        method: \"POST\",\n        headers: {\n            Authorization: `Bearer ${options.apiKey}`,\n        },\n        body: JSON.stringify({\n            environment: options.environment,\n            fileName: path || \"/\",\n            action: \"deleteDirectory\",\n        }),\n    });\n}\n\n/**\n * List all files and directories inside a directory, inside the uploads-folder on the configured HBO-ICT.Cloud environment.\n *\n * @param path - Path to the directory to list, can contain forward slashes (/) to access subfolders.\n *\n * @returns Returns a promise which can either fail (`string` with reason) or succeed (`string[]` with files and directories).\n *\n * @example\n * Below is a simplified example.\n *\n * ```ts\n * import { api } from \"@hboictcloud/api\";\n *\n * const data = await api.listDirectory(\"test\");\n * console.log(data);\n * ```\n */\nexport function listDirectory(path: string): Promise<string[] | ApiFailReason> {\n    assertConfiguration();\n\n    /*if (!path) {\n            return Promise.reject(\"path cannot be empty!\");\n        }*/\n\n    return handleFetch<string[]>(options.url + \"/file\", {\n        method: \"POST\",\n        headers: {\n            Authorization: `Bearer ${options.apiKey}`,\n        },\n        body: JSON.stringify({\n            environment: options.environment,\n            fileName: path || \"/\",\n            action: \"list\",\n        }),\n    });\n}\n\n/**\n * Checks if a directory exists inside the uploads-folder on the configured HBO-ICT.Cloud environment.\n *\n * @param path - Path to the directory to check for existence, can contain forward slashes (/) to access subfolders.\n *\n * @returns Returns a promise which can either fail (`string` with reason) or succeed (`boolean` set to `true` if directory exists, otherwise `false`).\n *\n * @example\n * Below is a simplified example.\n *\n * ```ts\n * import { api } from \"@hboictcloud/api\";\n *\n * const data = await api.directoryExists(\"test\");\n * console.log(data);\n * ```\n */\nexport function directoryExists(\n    path: string,\n): Promise<boolean | ApiFailReason> {\n    assertConfiguration();\n\n    if (!path) {\n        return Promise.reject(\"path cannot be empty!\");\n    }\n\n    return handleFetch<boolean>(options.url + \"/file\", {\n        method: \"POST\",\n        headers: {\n            Authorization: `Bearer ${options.apiKey}`,\n        },\n        body: JSON.stringify({\n            environment: options.environment,\n            fileName: path,\n            action: \"directoryExists\",\n        }),\n    });\n}\n\nfunction handleFetch<T = any>(\n    url: string,\n    fetchOptions: RequestInit,\n): Promise<T | ApiFailReason> {\n    return new Promise(\n        async (resolve: PromiseResolve, reject: PromiseReject) => {\n            let response: Response;\n\n            try {\n                response = await fetch(url, fetchOptions);\n            } catch (error) {\n                apiFail(reject, 500, error);\n\n                return;\n            }\n\n            try {\n                const json = await response.json();\n\n                if (response.status === 200) {\n                    resolve(json);\n                } else {\n                    apiFail(\n                        reject,\n                        response.status,\n                        (<ApiFailResponse>json).reason,\n                    );\n                }\n            } catch (error) {\n                apiFail(reject, 500, error);\n            }\n        },\n    );\n}\n\nfunction apiFail(\n    reject: PromiseReject,\n    statusCode: number,\n    reason?: string | any,\n): void {\n    if (statusCode === 400) {\n        reject(reason || \"Something bad happened, see console.\");\n    } else {\n        reject(\"Something bad happened, see console.\");\n    }\n}\n\nfunction assertConfiguration(): void {\n    if (!options) {\n        throw \"HBO-ICT.Cloud API is not properly configured!\";\n    }\n}\n","/**\n * Localization-extension for the HBO-ICT.Cloud library\n *\n * @module\n */\nlet translations: any = undefined!;\nlet activeLanguage: string = undefined!;\n\n/**\n * Register all the translations to localize a webpage\n *\n * @param translations - Free-form object with all translations\n *\n * @example\n * ```ts\n * import { localization } from \"@hboictcloud/api\";\n *\n * localization.setTranslations({\n *      okButton: {\n *          nl: \"Oke!\",\n *          en: \"OK!\"\n *      }\n * });\n * ```\n */\nexport function setTranslations(translationObject: any): void {\n    translations = translationObject;\n}\n\n/**\n * Switch the active language, will be immediately applied.\n *\n * @param language - Name of the language to activate\n */\nexport function switchLanguage(language: string): void {\n    activeLanguage = language;\n\n    translate(true);\n}\n\n/**\n * Apply the translations for the active language, useful for dynamic changes on a webpage. This will only translate texts inside elements, not their attributes (for example `placeholder`)!\n *\n * @param [force] - Set to `true` to translate everything on a webpage, otherwise `false` to only translate untranslated parts (Default: `false`).\n */\nexport function translate(force: boolean = false): void {\n    const selector = force\n        ? \"[data-translate]\"\n        : \"[data-translate]:not([translated])\";\n\n    document.querySelectorAll(selector).forEach((element: Element) => {\n        const localizeKey = (<HTMLElement>element).dataset.translate!;\n        const localizeKeys = localizeKey.split(\".\");\n\n        let result = translations;\n\n        for (let i = 0; i < localizeKeys.length; i++) {\n            result = result[localizeKeys[i]];\n\n            if (result === undefined) {\n                break;\n            }\n        }\n\n        element.setAttribute(\"translated\", \"\");\n        element.innerHTML =\n            result && result[activeLanguage]\n                ? result[activeLanguage]\n                : `[${localizeKey}]`;\n    });\n}\n","/**\n * Utils-extension for the HBO-ICT.Cloud library\n *\n * @module\n */\nimport { DataURL, QueryStringObject } from \"./types\";\n\nconst alphaNumeric =\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nconst symbols = \" `!\\\"$%^&*()-_=+[{]};:'@#~|,<.>/?\\\\\";\nconst alphaNumericWithSymbols = alphaNumeric + symbols;\nconst domParser = new DOMParser();\n\n/**\n * Convert a file-input to a Data-URL\n *\n * @param fileInput - HTMLInputElement or DOM-selector of the file-input.\n *\n * @returns Returns a promise which can either fail (`string` with reason) or succeed ({@link DataURL | `DataURL`} of the file).\n *\n * @example\n * ```ts\n * import { utils } from \"@hboictcloud/api\";\n *\n * try {\n *     const data = await utils.getDataUrl(\"#fileInput\");\n *\n *     console.log(data);\n * }\n * catch(reason) {\n *     console.log(reason);\n * }\n * ```\n */\nexport function getDataUrl(\n    fileInput: HTMLInputElement | string,\n): Promise<DataURL | string> {\n    return new Promise(function (resolve, reject) {\n        const element: HTMLInputElement =\n            typeof fileInput === \"string\"\n                ? <HTMLInputElement>document.querySelector(fileInput)\n                : fileInput;\n\n        let file;\n        let fileName: string;\n\n        if (element) {\n            file = element.files![0];\n            fileName = element.value.split(/(\\\\|\\/)/g).pop()!;\n        } else {\n            reject(\"Could not find element!\");\n\n            return;\n        }\n\n        const reader = new FileReader();\n\n        reader.addEventListener(\n            \"load\",\n            function () {\n                const dataUrl = <string>reader.result;\n\n                const mimeType = dataUrl.match(\"^data:(.*?);base64,\")![1];\n\n                const extensionIndex = fileName.lastIndexOf(\".\");\n\n                resolve({\n                    fileName: fileName,\n                    extension:\n                        extensionIndex > -1\n                            ? fileName.substring(extensionIndex + 1)\n                            : \"\",\n                    mimeType: mimeType,\n                    isImage: mimeType.indexOf(\"image/\") >= 0,\n                    url: dataUrl,\n                });\n            },\n            false,\n        );\n\n        if (file) {\n            reader.readAsDataURL(file);\n        } else {\n            reject(`Could not load ${fileName || \"file\"}!`);\n        }\n    });\n}\n\n/**\n * Create a URL with a querystring\n *\n * @param url - Absolute or relative URL\n * @param queryString - Object with all keys to add to the querystring\n *\n * @returns Returns the created URL\n *\n * @example\n * ```ts\n * import { utils } from \"@hboictcloud/api\";\n *\n * const url = utils.createUrl(\"matches.html\", {\n *     search: \"paris\",\n *     filters: [\n *         \"tagA\",\n *         \"tagB\"\n *     ]\n * });\n *\n * console.log(url); //matches.html?search=paris&filters=tagA&filters=tagB\n * ```\n */\nexport function createUrl(\n    url: string,\n    queryString?: QueryStringObject,\n): string {\n    let targetUrl = url;\n\n    if (queryString && Object.keys(queryString).length > 0) {\n        targetUrl += `?${createQueryString(queryString)}`;\n    }\n\n    return targetUrl;\n}\n\n/**\n * Generate a `string` of random characters\n *\n * @param length - Length of the `string` to generate\n * @param includeSymbols - Set to `true` to include non-alphanumeric characters, otherwise `false`.\n *\n * @returns Returns the generated random string\n */\nexport function randomString(length: number, includeSymbols: boolean): string {\n    const characters = includeSymbols ? alphaNumericWithSymbols : alphaNumeric;\n\n    const result = [];\n\n    for (let i = 0; i < length; i++) {\n        result.push(\n            characters.charAt(Math.floor(Math.random() * characters.length)),\n        );\n    }\n\n    return result.join(\"\");\n}\n\n/**\n * Convert a Date-object to an SQL accepted String-format\n *\n * @param inputDate - Date-object to convert\n *\n * @returns SQL accepted String-format of the Date-object\n */\nexport function toSqlDateTime(inputDate: Date): string {\n    const date = new Date(inputDate);\n    const dateWithOffset = new Date(\n        date.getTime() - date.getTimezoneOffset() * 60000,\n    );\n\n    return dateWithOffset.toISOString().slice(0, 19).replace(\"T\", \" \");\n}\n\n/**\n * Create a copy of a object\n *\n * @param object - Object to copy\n *\n * @returns Copy of the object\n */\nexport function copyObject(object: any): any {\n    return handleCopyObject(object);\n}\n\n/**\n * Create a querystring of all keys in a given object\n *\n * @param object - Object to convert to a querystring\n *\n * @returns Querystring of all keys in the object\n *\n * @example\n * ```ts\n * import { utils } from \"@hboictcloud/api\";\n *\n * const queryString = utils.createQueryString({\n *     search: \"paris\",\n *     filters: [\n *         \"tagA\",\n *         \"tagB\"\n *     ]\n * });\n *\n * console.log(queryString); //search=paris&filters=tagA&filters=tagB\n * ```\n */\nexport function createQueryString(object: Object): string {\n    if (!object) {\n        return \"\";\n    }\n\n    const urlParams = new URLSearchParams();\n\n    for (const [name, value] of Object.entries(object)) {\n        if (Array.isArray(value)) {\n            for (const entry of value) {\n                urlParams.append(name, entry || \"\");\n            }\n        } else {\n            urlParams.append(name, <string>value || \"\");\n        }\n    }\n\n    return urlParams.toString();\n}\n\n/**\n * Parse all keys of a given querystring to an object\n *\n * @param queryString - Querystring to parse to an object\n *\n * @returns Object with all the keys found in the querystring\n */\nexport function parseQueryString(queryString: string): any {\n    return handleQueryString(queryString);\n}\n\n/**\n * Parse a `string` containing HTML to a list of HTML elements\n *\n * @param html - HTML to parse to a list of HTML elements\n *\n * @returns List of all HTML elements\n */\nexport function parseHtml(html: string): NodeList {\n    const htmlDocument = domParser.parseFromString(html, \"text/html\");\n\n    return htmlDocument.body.childNodes;\n}\n\n/**\n * Download a file from a given URL as text and parse it to a list of HTML elements\n *\n * @param url - URL of the HTML-file to download and parse\n * @param options - Additional fetch-configuration to apply during the download\n *\n * @returns Returns a promise with a list of all HTML elements\n */\nexport async function fetchAndParseHtml(\n    url: string,\n    options?: RequestInit,\n): Promise<NodeList> {\n    const data = await fetchText(url, options);\n\n    return parseHtml(data);\n}\n\n/**\n * Download a file from a given URL as text\n *\n * @param url - URL of the file to download as text\n * @param options - Additional fetch-configuration to apply during the download\n *\n * @returns Returns a promise with the downloaded text as a string\n */\nexport async function fetchText(\n    url: string,\n    options?: RequestInit,\n): Promise<string> {\n    const response = await fetch(url, options);\n\n    return response.text();\n}\n\n/**\n * Download a file from a given URL as JSON\n *\n * @param url - URL of the file to download as JSON\n * @param options - Additional fetch-configuration to apply during the download\n *\n * @returns Returns a promise with the downloaded JSON as an object\n */\nexport async function fetchJson(\n    url: string,\n    options?: RequestInit,\n): Promise<any> {\n    const response = await fetch(url, options);\n\n    return response.json();\n}\n\n/**\n * Download a file from a given URL as a blob\n *\n * @param url URL of the file to download as a blob\n * @param options - Additional fetch-configuration to apply during the download\n *\n * @returns Returns a promise with the downloaded file as a blob-object\n */\nexport async function fetchBlob(\n    url: string,\n    options?: RequestInit,\n): Promise<Blob> {\n    const response = await fetch(url, options);\n\n    return response.blob();\n}\n\n//Source: https://stackoverflow.com/a/25921504/890815\nfunction handleCopyObject(object: any): any {\n    const result: any = Array.isArray(object) ? [] : {};\n\n    let key;\n    let value;\n\n    for (key in object) {\n        value = object[key];\n\n        result[key] =\n            typeof value === \"object\" && value !== null\n                ? copyObject(value)\n                : value;\n    }\n\n    return result;\n}\n\n//Source: https://github.com/medialize/URI.js/blob/gh-pages/src/URI.js\nfunction handleQueryString(string: string): any {\n    if (!string) {\n        return {};\n    }\n\n    // throw out the funky business - \"?\"[name\"=\"value\"&\"]+\n    string = string.replace(/&+/g, \"&\").replace(/^\\?*&*|&+$/g, \"\");\n\n    if (!string) {\n        return {};\n    }\n\n    const items: any = {};\n    const splits = string.split(\"&\");\n    const length = splits.length;\n\n    let v, name, value;\n\n    for (let i = 0; i < length; i++) {\n        v = splits[i].split(\"=\");\n        name = decodeQuery(v.shift()!);\n        // no \"=\" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters\n        value = v.length ? decodeQuery(v.join(\"=\")) : null;\n\n        if (Object.prototype.hasOwnProperty.call(items, name)) {\n            if (typeof items[name] === \"string\" || items[name] === null) {\n                items[name] = [items[name]];\n            }\n\n            items[name].push(value);\n        } else {\n            items[name] = value;\n        }\n    }\n\n    return items;\n}\n\nfunction decodeQuery(string: string): string {\n    string += \"\";\n\n    try {\n        return decodeURIComponent(string);\n    } catch (e) {\n        return string;\n    }\n}\n","/**\n * Session-extension for the HBO-ICT.Cloud library\n *\n * @module\n */\nimport { copyObject } from \"./utils\";\n\nlet session: any = {};\n\nloadSession();\n\n/**\n * Get all keys from the session as an object\n *\n * @returns Returns an object containing all keys in the session\n */\nexport function getAll(): any {\n    return copyObject(session);\n}\n\n/**\n * Get a specific key from the session. If you need multiple keys from the session, it's better to use {@link getAll} instead.\n *\n * @param key - Name of the key to get\n * @param [defaultValue] - Value to return if the key does not exist or returns empty. (Default: `undefined`)\n *\n * @returns Returns the value of the key, or the specified default value\n */\nexport function get(key: string, defaultValue: any = undefined): any {\n    //Instead of copying the whole session, just copy the requested key, if it exists.\n    if (session[key]) {\n        const copy = copyObject({\n            temp: session[key],\n        });\n\n        return copy.temp;\n    }\n\n    return defaultValue;\n}\n\n/**\n * Set a specific key in the session\n *\n * @param key - Name of the key to set\n * @param value - Value to set the key to\n */\nexport function set(key: string, value: any): void {\n    session[key] = value;\n\n    saveSession();\n}\n\n/**\n * Remove a specific key from the session\n *\n * @param key - Name of the key to remove\n */\nexport function remove(key: string): void {\n    delete session[key];\n\n    saveSession();\n}\n\n/**\n * Remove all data from the session\n */\nexport function clear(): void {\n    session.clear();\n\n    saveSession();\n}\n\nfunction loadSession(): void {\n    try {\n        const loadedSession = localStorage.getItem(\"session\");\n\n        if (loadedSession) {\n            session = JSON.parse(loadedSession);\n        }\n    } catch (e) {\n        //Do nothing\n    }\n\n    if (!session) {\n        session = {};\n\n        saveSession();\n    }\n}\n\nfunction saveSession(): void {\n    localStorage.setItem(\"session\", JSON.stringify(session));\n}\n","/**\n * URL-extension for the HBO-ICT.Cloud library\n *\n * @module\n */\nimport { QueryStringObject } from \"./types\";\nimport { createUrl, parseQueryString } from \"./utils\";\n\n/**\n * Get the querystring as an object\n *\n * @returns Returns the querystring as an object\n */\nexport function getQueryStringAsObject(): any {\n    return parseQueryString(window.location.search);\n}\n\n/**\n * Get a specific key from the querystring. If you need multiple keys from the querystring, it's better to use {@link getQueryStringAsObject} instead.\n *\n * @param key - Name of the key to get\n * @param [defaultValue] - Value to return if the key does not exist or returns empty. (Default: `undefined`)\n *\n * @returns Returns the value of the key, or the specified default value.\n *\n * @example\n * ```ts\n * import { url } from \"@hboictcloud/api\";\n *\n * //URL: profile.html?id=15\n * const id = url.getFromQueryString(\"id\");\n * console.log(id); //15\n * ```\n */\nexport function getFromQueryString(\n    key: string,\n    defaultValue: any = undefined,\n): any {\n    const copy = parseQueryString(window.location.search);\n\n    return copy[key] || defaultValue;\n}\n\n/**\n * Redirect the browser to a new URL, leaving the current URL in the back/forward browser-history.\n *\n * @param url - Absolute or relative URL to redirect to\n * @param queryString - Object with all keys to add to the querystring\n *\n * @example\n * ```ts\n * import { url } from \"@hboictcloud/api\";\n *\n * url.redirect(\"profile.html\", {\n *     id: 15\n * });\n * ```\n */\nexport function redirect(url: string, queryString?: QueryStringObject): void {\n    window.location.assign(createUrl(url, queryString));\n}\n\n/**\n * Replace the URL visible in the browser, also replacing the current URL in the back/forward browser-history. Doesn't actually redirect the page, just updates the URL.\n *\n * @param url - Absolute or relative URL to redirect to\n * @param queryString - Object with all keys to add to the querystring\n *\n * @example\n * ```ts\n * import { url } from \"@hboictcloud/api\";\n *\n * url.replace(\"profile.html\", {\n *     id: 15\n * });\n * ```\n */\nexport function replace(url: string, queryString?: QueryStringObject): void {\n    history.replaceState({}, \"\", createUrl(url, queryString));\n}\n"],"names":["options","configure","newOptions","errors","queryDatabase","query","values","assertConfiguration","handleFetch","sendEmail","email","uploadFile","fileName","dataUrl","overwrite","deleteFile","fileExists","deleteDirectory","path","listDirectory","directoryExists","url","fetchOptions","resolve","reject","response","error","apiFail","json","statusCode","reason","translations","activeLanguage","setTranslations","translationObject","switchLanguage","language","translate","force","selector","element","localizeKey","localizeKeys","result","i","alphaNumeric","symbols","alphaNumericWithSymbols","domParser","getDataUrl","fileInput","file","reader","mimeType","extensionIndex","createUrl","queryString","targetUrl","createQueryString","randomString","length","includeSymbols","characters","toSqlDateTime","inputDate","date","copyObject","object","handleCopyObject","urlParams","name","value","entry","parseQueryString","handleQueryString","parseHtml","html","fetchAndParseHtml","data","fetchText","fetchJson","fetchBlob","key","string","items","splits","v","decodeQuery","session","loadSession","getAll","get","defaultValue","set","saveSession","remove","clear","loadedSession","getQueryStringAsObject","getFromQueryString","redirect","replace"],"mappings":"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"}